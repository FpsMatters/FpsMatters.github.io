<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>IA Premium</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    @font-face {
      font-family: 'SF Pro Text';
      src: local('SF Pro Text'), local('SFProText-Regular');
      font-weight: 700;
      font-style: normal;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      width: 100vw;
      height: 100vh;
      font-family: 'SF Pro Text', 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    }
    .glow-text {
      width: 100vw;
      text-align: center;
      color: #fff;
      font-size: clamp(2.5rem, 7vw, 5rem);
      font-weight: 700;
      letter-spacing: 0.01em;
      margin-top: 32px;
      margin-bottom: 0;
      text-shadow: 0 0 4px #fff, 0 0 10px #fff2;
      opacity: 0;
      transform: scale(0.96);
      animation: fadeInScale 1.2s cubic-bezier(.23,1.12,.64,1) forwards;
      user-select: none;
      line-height: 1.2;
      z-index: 2;
      position: relative;
    }
    @keyframes fadeInScale {
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    #robot-canvas {
      display: block;
      margin: 0 auto;
      position: absolute;
      left: 50%;
      top: 100px;
      transform: translateX(-50%);
      z-index: 1;
    }
    @media (max-width: 600px) {
      .glow-text { font-size: 2rem; }
      #robot-canvas { width: 100vw !important; height: 60vw !important; top: 80px; }
    }
  </style>
</head>
<body>
  <h1 class="glow-text">
    L’IA, c’est maintenant.
  </h1>
  <canvas id="robot-canvas"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // Responsive canvas sizing
    function getCanvasSize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const size = Math.min(w, h - 120, 500);
      return { width: size, height: size * 1.1 };
    }
    const canvas = document.getElementById('robot-canvas');
    let { width, height } = getCanvasSize();
    canvas.width = width;
    canvas.height = height;

    // Three.js scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 1.2, 6);

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000, 0);

    // Soft light
    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(3, 10, 10);
    scene.add(dirLight);

    // Robot group
    const robot = new THREE.Group();

    // Body
    const bodyGeo = new THREE.CylinderGeometry(0.7, 0.9, 1.7, 32);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.3, roughness: 0.5 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0;
    robot.add(body);

    // Head
    const headGeo = new THREE.SphereGeometry(0.7, 32, 32);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.3 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.2;
    robot.add(head);

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(0.09, 16, 16);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x0099ff, emissive: 0x0099ff, emissiveIntensity: 0.7 });
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.23, 1.28, 0.65);
    const rightEye = leftEye.clone();
    rightEye.position.x = 0.23;
    robot.add(leftEye, rightEye);

    // Blush (cute effect)
    const blushGeo = new THREE.SphereGeometry(0.07, 16, 16);
    const blushMat = new THREE.MeshStandardMaterial({ color: 0xff7eb9, emissive: 0xff7eb9, emissiveIntensity: 0.3 });
    const leftBlush = new THREE.Mesh(blushGeo, blushMat);
    leftBlush.position.set(-0.36, 1.1, 0.61);
    const rightBlush = leftBlush.clone();
    rightBlush.position.x = 0.36;
    robot.add(leftBlush, rightBlush);

    // Mouth
    const mouthGeo = new THREE.TorusGeometry(0.16, 0.025, 16, 100, Math.PI);
    const mouthMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.2, roughness: 0.7 });
    const mouth = new THREE.Mesh(mouthGeo, mouthMat);
    mouth.position.set(0, 1.05, 0.62);
    mouth.rotation.x = Math.PI / 2;
    robot.add(mouth);

    // Antenna
    const antennaGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.35, 16);
    const antennaMat = new THREE.MeshStandardMaterial({ color: 0x0099ff, metalness: 0.8, roughness: 0.3 });
    const antenna = new THREE.Mesh(antennaGeo, antennaMat);
    antenna.position.set(0, 1.65, 0);
    robot.add(antenna);

    const antennaBallGeo = new THREE.SphereGeometry(0.09, 16, 16);
    const antennaBallMat = new THREE.MeshStandardMaterial({ color: 0x0099ff, emissive: 0x0099ff, emissiveIntensity: 0.9 });
    const antennaBall = new THREE.Mesh(antennaBallGeo, antennaBallMat);
    antennaBall.position.set(0, 1.86, 0);
    robot.add(antennaBall);

    // Arms
    const armGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.8, 16);
    const armMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.4, roughness: 0.4 });
    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.95, 0.5, 0);
    leftArm.rotation.z = Math.PI / 4;
    const rightArm = leftArm.clone();
    rightArm.position.x = 0.95;
    rightArm.rotation.z = -Math.PI / 4;
    robot.add(leftArm, rightArm);

    // Legs
    const legGeo = new THREE.CylinderGeometry(0.13, 0.13, 0.7, 16);
    const legMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.4, roughness: 0.4 });
    const leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.33, -1, 0);
    const rightLeg = leftLeg.clone();
    rightLeg.position.x = 0.33;
    robot.add(leftLeg, rightLeg);

    // Add to scene
    scene.add(robot);

    // Animation variables
    let blink = 0, blinkSpeed = 0.07, blinkTimer = 0, bounce = 0;

    // Animate
    function animate() {
      requestAnimationFrame(animate);

      // Bouncing
      bounce += 0.025;
      robot.position.y = Math.sin(bounce) * 0.12;

      // Head tilt
      head.rotation.z = Math.sin(bounce) * 0.08;

      // Arm wave
      leftArm.rotation.x = Math.sin(bounce) * 0.25 + 0.1;
      rightArm.rotation.x = -Math.sin(bounce) * 0.25 + 0.1;

      // Blinking
      blinkTimer += blinkSpeed;
      if (blinkTimer > 2 * Math.PI) blinkTimer = 0;
      let eyeScaleY = (Math.sin(blinkTimer) > 0.97) ? 0.2 : 1;
      leftEye.scale.y = rightEye.scale.y = eyeScaleY;

      renderer.render(scene, camera);
    }
    animate();

    // Responsive resize
    window.addEventListener('resize', () => {
      const size = getCanvasSize();
      width = size.width;
      height = size.height;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
